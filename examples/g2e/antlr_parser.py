#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Tatsu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from tatsu.buffering import Buffer
from tatsu.parsing import graken, Parser
from tatsu.util import re, RE_FLAGS, generic_main  # noqa


KEYWORDS = {}


class ANTLRBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(ANTLRBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class ANTLRParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=ANTLRBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(ANTLRParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _grammar_(self):
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('lexer')
                    with self._option():
                        self._token('parser')
                    self._error('expecting one of: lexer parser')
        self._token('grammar')
        self._name_()
        self.name_last_node('name')
        self._token(';')
        with self._optional():
            self._options_()
        with self._optional():
            self._header_()
        with self._optional():
            self._members_()
        with self._optional():
            self._imports_()
        with self._optional():
            self._tokens_()

        def block2():
            self._scope_()
        self._closure(block2)

        def block3():
            self._action_()
        self._closure(block3)

        def block5():
            self._rule_()
        self._positive_closure(block5)
        self.name_last_node('rules')
        self._check_eof()
        self.ast._define(
            ['name', 'rules'],
            []
        )

    @graken()
    def _options_(self):
        self._token('options')
        self._token('{')

        def block0():
            self._option_()
        self._positive_closure(block0)
        self._token('}')
        self._cut()

    @graken()
    def _option_(self):
        self._id_()
        self._token('=')
        with self._group():
            with self._choice():
                with self._option():
                    self._id_()
                with self._option():
                    self._string_()
                with self._option():
                    self._char_()
                with self._option():
                    self._int_()
                with self._option():
                    self._token('*')
                self._error('expecting one of: *')
        self._token(';')
        self._cut()

    @graken()
    def _imports_(self):
        self._token('import')
        self._name_()

        def block0():
            self._token(',')
            self._name_()
        self._closure(block0)
        self._token(';')

    @graken()
    def _header_(self):
        self._token('@header')
        self._block_()

    @graken()
    def _members_(self):
        self._token('@members')
        self._block_()

    @graken()
    def _tokens_(self):
        self._token('tokens')
        self._token('{')

        def block0():
            self._token_()
        self._positive_closure(block0)
        self._token('}')

    @graken()
    def _token_(self):
        self._token_name_()
        self.name_last_node('name')
        with self._optional():
            self._token('=')
            self._cut()
            self._token_value_()
            self.name_last_node('exp')
        self._token(';')
        self._cut()
        self.ast._define(
            ['exp', 'name'],
            []
        )

    @graken()
    def _token_value_(self):
        self._literal_()

    @graken()
    def _scope_(self):
        self._token('scope')
        self._cut()
        with self._group():
            with self._choice():
                with self._option():
                    self._block_()
                    with self._optional():
                        self._token('scope')
                        self._id_()

                        def block0():
                            self._token(',')
                            self._id_()
                        self._closure(block0)
                        self._token(';')
                with self._option():
                    self._id_()

                    def block1():
                        self._token(',')
                        self._id_()
                    self._closure(block1)
                    self._token(';')
                with self._option():
                    self._id_()
                    self._block_()
                self._error('no available options')

    @graken()
    def _action_(self):
        self._token('@')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('lexer')
                with self._option():
                    self._token('parser')
                with self._option():
                    self._id_()
                self._error('expecting one of: lexer parser')
        with self._optional():
            self._token('::')
            self._id_()
        self._block_()

    @graken()
    def _block_(self):
        self._token('{')

        def block0():
            with self._choice():
                with self._option():
                    self._block_()
                with self._option():
                    self._pattern(r'[^{}]*')
                self._error('expecting one of: [^{}]*')
        self._closure(block0)
        self._token('}')

    @graken()
    def _rule_(self):
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('protected')
                with self._option():
                    self._token('public')
                with self._option():
                    self._token('private')
                with self._option():
                    self._token('fragment')
                    self.name_last_node('fragment')
                self._error('expecting one of: fragment private protected public')
        self._id_()
        self.name_last_node('name')
        with self._optional():
            self._token('!')
        with self._optional():
            self._arg_()
        with self._optional():
            self._token('returns')
            self._arg_()
        with self._optional():
            self._token('trhows')
            self._id_()

            def block3():
                self._token(',')
                self._id_()
            self._closure(block3)
        with self._optional():
            self._options_()
        with self._optional():
            self._scope_()

        def block4():
            self._action_()
        self._closure(block4)
        self._token(':')
        self._alternatives_()
        self.name_last_node('exp')
        self._token(';')
        self._cut()
        with self._optional():
            self._exceptions_()
        self.ast._define(
            ['exp', 'fragment', 'name'],
            []
        )

    @graken()
    def _arg_(self):
        self._token('[')
        self._cut()

        def block0():
            with self._choice():
                with self._option():
                    self._arg_()
                with self._option():
                    self._pattern(r'[^\]]*')
                self._error('expecting one of: [^\\]]*')
        self._closure(block0)
        self._token(']')

    @graken()
    def _exceptions_(self):

        def block0():
            self._token('catch')
            self._arg_()
            self._block_()
        self._closure(block0)
        with self._optional():
            self._token('finally')
            self._block_()

    @graken()
    def _alternatives_(self):

        def sep0():
            self._token('|')

        def block0():
            with self._optional():
                self._annotation_()
            self._alternative_()
            self.add_last_node_to_name('options')
        self._positive_gather(block0, sep0)
        self.ast._define(
            [],
            ['options']
        )

    @graken()
    def _alternative_(self):
        self._elements_()
        self.name_last_node('@')
        with self._optional():
            self._token('->')
            self._rewrite_()

    @graken()
    def _elements_(self):

        def block0():
            self._element_()
        self._closure(block0)

    @graken()
    def _element_(self):
        with self._choice():
            with self._option():
                self._named_()
            with self._option():
                self._predicate_or_action_()
            with self._option():
                self._optional_()
            with self._option():
                self._closure_()
            with self._option():
                self._positive_closure_()
            with self._option():
                self._atom_()
            self._error('no available options')

    @graken()
    def _named_(self):
        self._id_()
        self.name_last_node('name')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('+=')
                    self.name_last_node('force_list')
                with self._option():
                    self._token('=')
                self._error('expecting one of: += =')
        self._atom_()
        self.name_last_node('exp')
        self.ast._define(
            ['exp', 'force_list', 'name'],
            []
        )

    @graken()
    def _predicate_or_action_(self):
        with self._choice():
            with self._option():
                self._gated_predicate_()
            with self._option():
                self._semantic_predicate_()
            with self._option():
                self._semantic_action_()
            self._error('no available options')

    @graken()
    def _gated_predicate_(self):
        self._block_()
        self._token('?=>')
        self._cut()

    @graken()
    def _semantic_predicate_(self):
        self._block_()
        self._token('?')
        self._cut()

    @graken()
    def _semantic_action_(self):
        self._token('{')

        def block0():
            with self._choice():
                with self._option():
                    self._semantic_action_()
                with self._option():
                    self._pattern(r'[^}]')
                self._error('expecting one of: [^}]')
        self._closure(block0)
        self._token('}')

    @graken()
    def _syntactic_predicate_(self):
        self._subexp_()
        self.name_last_node('@')
        self._token('=>')
        self._cut()

    @graken()
    def _optional_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('(')
                    self._alternatives_()
                    self.name_last_node('@')
                    self._token(')')
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._closure_()
                            with self._option():
                                self._positive_closure_()
                            with self._option():
                                self._atom_()
                            self._error('no available options')
                    self.name_last_node('@')
                self._error('no available options')
        self._token('?')
        self._cut()

    @graken()
    def _closure_(self):
        self._atom_()
        self.name_last_node('@')
        self._token('*')
        self._cut()

    @graken()
    def _positive_closure_(self):
        self._atom_()
        self.name_last_node('@')
        self._token('+')
        self._cut()

    @graken()
    def _atom_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._eof_()
                with self._option():
                    self._newranges_()
                with self._option():
                    self._negative_()
                with self._option():
                    self._regexp_()
                with self._option():
                    self._syntactic_predicate_()
                with self._option():
                    self._subexp_()
                with self._option():
                    self._terminal_()
                with self._option():
                    self._non_terminal_()
                self._error('no available options')
        self.name_last_node('@')
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('^')
                with self._option():
                    self._token('!')
                self._error('expecting one of: ! ^')
        with self._optional():
            self._annotation_()

    @graken()
    def _annotation_(self):
        self._token('<')

        def sep0():
            self._token(',')

        def block0():
            self._id_()
            with self._optional():
                self._token('=')
                self._id_()
        self._positive_gather(block0, sep0)
        self._token('>')

    @graken()
    def _eof_(self):
        self._token('EOF')

    @graken()
    def _regexp_(self):

        def block0():
            self._charset_()
        self._positive_closure(block0)

    @graken()
    def _charset_(self):
        with self._choice():
            with self._option():
                self._charset_optional_()
            with self._option():
                self._charset_closure_()
            with self._option():
                self._charset_positive_closure_()
            with self._option():
                self._charset_term_()
            self._error('no available options')

    @graken()
    def _charset_optional_(self):
        self._token('(')
        self._charset_()
        self.name_last_node('@')
        self._token(')')
        self._token('?')
        self._cut()

    @graken()
    def _charset_closure_(self):
        self._token('(')
        self._charset_()
        self.name_last_node('@')
        self._token(')')
        self._token('*')
        self._cut()

    @graken()
    def _charset_positive_closure_(self):
        self._token('(')
        self._charset_()
        self.name_last_node('@')
        self._token(')')
        self._token('+')
        self._cut()

    @graken()
    def _charset_term_(self):
        with self._choice():
            with self._option():
                self._token('(')
                self._charset_()
                self.name_last_node('@')
                self._token(')')
            with self._option():
                self._charset_negative_or_()
            with self._option():
                self._charset_or_()
            self._error('no available options')

    @graken()
    def _charset_or_(self):
        with self._choice():
            with self._option():
                self._charset_range_()
                self.add_last_node_to_name('@')

                def block1():
                    self._token('|')
                    self._charset_atom_()
                    self.add_last_node_to_name('@')
                self._closure(block1)
            with self._option():
                self._charset_char_()
                self.add_last_node_to_name('@')

                def block4():
                    self._token('|')
                    self._charset_atom_()
                    self.add_last_node_to_name('@')
                self._positive_closure(block4)
            self._error('no available options')

    @graken()
    def _charset_negative_or_(self):
        self._token('~')
        self._token('(')
        with self._group():
            with self._choice():
                with self._option():
                    self._charset_range_()
                    self.add_last_node_to_name('@')

                    def block1():
                        self._token('|')
                        self._charset_atom_()
                        self.add_last_node_to_name('@')
                    self._closure(block1)
                with self._option():
                    self._charset_char_()
                    self.add_last_node_to_name('@')

                    def block4():
                        self._token('|')
                        self._charset_atom_()
                        self.add_last_node_to_name('@')
                    self._positive_closure(block4)
                self._error('no available options')
        self._token(')')

    @graken()
    def _charset_atom_(self):
        with self._choice():
            with self._option():
                self._charset_range_()
            with self._option():
                self._char_()
            self._error('no available options')

    @graken()
    def _charset_char_(self):
        self._char_()

    @graken()
    def _charset_range_(self):
        self._charset_char_()
        self.name_last_node('first')
        self._token('..')
        self._charset_char_()
        self.name_last_node('last')
        self.ast._define(
            ['first', 'last'],
            []
        )

    @graken()
    def _newranges_(self):

        def block0():
            with self._choice():
                with self._option():
                    self._negative_newrange_()
                with self._option():
                    self._newrange_()
                self._error('no available options')
        self._positive_closure(block0)

    @graken()
    def _newrange_(self):
        self._token('[')
        self._pattern(r'([^\]]|\\u[a-fA-F0-9]{4}|\\.)+')
        self.name_last_node('range')
        self._token(']')
        with self._optional():
            self._pattern(r'[+*?][?]?')
        self.name_last_node('repeat')
        self.ast._define(
            ['range', 'repeat'],
            []
        )

    @graken()
    def _negative_newrange_(self):
        self._token('~')
        self._token('[')
        self._pattern(r'([^\]]|\\u[a-fA-F0-9]{4}|\\.)+')
        self.name_last_node('range')
        self._token(']')
        with self._optional():
            self._pattern(r'[+*?][?]?')
        self.name_last_node('repeat')
        self.ast._define(
            ['range', 'repeat'],
            []
        )

    @graken()
    def _subexp_(self):
        self._token('(')
        with self._optional():
            self._options_()
            self._token(':')
            self._cut()
        self._alternatives_()
        self.name_last_node('@')
        self._token(')')

    @graken()
    def _negative_(self):
        self._token('~')
        self._atom_()
        self.name_last_node('@')

    @graken()
    def _non_terminal_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token_ref_()
                with self._option():
                    self._rule_ref_()
                self._error('no available options')
        self.name_last_node('@')
        with self._optional():
            self._arg_()

    @graken()
    def _terminal_(self):
        with self._choice():
            with self._option():
                self._string_()
            with self._option():
                self._any_()
            self._error('no available options')

    @graken()
    def _any_(self):
        with self._ifnot():
            self._token('..')
        self._token('.')
        self._cut()

    @graken()
    def _rewrite_(self):

        def block0():
            self._rewrite_term_()
        self._closure(block0)

    @graken()
    def _rewrite_term_(self):
        with self._choice():
            with self._option():
                self._token('^(')

                def block0():
                    self._rewrite_term_()
                self._positive_closure(block0)
                self._token(')')
            with self._option():
                self._pattern(r'[^|;^)]*')
            self._error('expecting one of: [^|;^)]*')

    @graken()
    def _rule_ref_(self):
        self._lower_name_()
        with self._optional():
            self._annotation_()

    @graken()
    def _token_ref_(self):
        self._upper_name_()

    @graken()
    def _token_name_(self):
        self._upper_name_()

    @graken()
    def _literal_(self):
        with self._choice():
            with self._option():
                self._id_()
            with self._option():
                self._string_()
            with self._option():
                self._int_()
            self._error('no available options')

    @graken()
    def _id_(self):
        self._name_()

    @graken()
    def _name_(self):
        self._pattern(r'[a-zA-Z][A-Za-z0-9_]*')

    @graken()
    def _lower_name_(self):
        self._pattern(r'[a-z][A-Za-z0-9_]*')

    @graken()
    def _upper_name_(self):
        self._pattern(r'[A-Z][A-Za-z0-9_]*')

    @graken()
    def _char_(self):
        self._token("'")
        self._pattern(r"[^'\n\\]|\\'|\\u[a-fA-F0-9]{4}|\\.")
        self.name_last_node('@')
        self._token("'")

    @graken()
    def _string_(self):
        self._STRING_()

    @graken()
    def _STRING_(self):
        with self._choice():
            with self._option():
                self._token('"')
                self._pattern(r'([^"\n\\]|\\u[a-fA-F0-9]{4}|\\[\'"\\nrtbfv])+')
                self.name_last_node('@')
                self._token('"')
            with self._option():
                self._token("'")
                self._pattern(r'([^\'\n\\]|\\u[a-fA-F0-9]{4}|\\[\'"\\nrtbfv])+')
                self.name_last_node('@')
                self._token("'")
            self._error('expecting one of: " \'')

    @graken()
    def _int_(self):
        self._pattern(r'[0-9]+')

    @graken()
    def _ESC_(self):
        with self._choice():
            with self._option():
                self._pattern(r'\\[\'"\\nrtbfv]')
            with self._option():
                self._pattern(r'\\u[a-fA-F0-9]{4}')
            self._error('expecting one of: \\\\[\'"\\\\nrtbfv] \\\\u[a-fA-F0-9]{4}')


class ANTLRSemantics(object):
    def grammar(self, ast):
        return ast

    def options(self, ast):
        return ast

    def option(self, ast):
        return ast

    def imports(self, ast):
        return ast

    def header(self, ast):
        return ast

    def members(self, ast):
        return ast

    def tokens(self, ast):
        return ast

    def token(self, ast):
        return ast

    def token_value(self, ast):
        return ast

    def scope(self, ast):
        return ast

    def action(self, ast):
        return ast

    def block(self, ast):
        return ast

    def rule(self, ast):
        return ast

    def arg(self, ast):
        return ast

    def exceptions(self, ast):
        return ast

    def alternatives(self, ast):
        return ast

    def alternative(self, ast):
        return ast

    def elements(self, ast):
        return ast

    def element(self, ast):
        return ast

    def named(self, ast):
        return ast

    def predicate_or_action(self, ast):
        return ast

    def gated_predicate(self, ast):
        return ast

    def semantic_predicate(self, ast):
        return ast

    def semantic_action(self, ast):
        return ast

    def syntactic_predicate(self, ast):
        return ast

    def optional(self, ast):
        return ast

    def closure(self, ast):
        return ast

    def positive_closure(self, ast):
        return ast

    def atom(self, ast):
        return ast

    def annotation(self, ast):
        return ast

    def eof(self, ast):
        return ast

    def regexp(self, ast):
        return ast

    def charset(self, ast):
        return ast

    def charset_optional(self, ast):
        return ast

    def charset_closure(self, ast):
        return ast

    def charset_positive_closure(self, ast):
        return ast

    def charset_term(self, ast):
        return ast

    def charset_or(self, ast):
        return ast

    def charset_negative_or(self, ast):
        return ast

    def charset_atom(self, ast):
        return ast

    def charset_char(self, ast):
        return ast

    def charset_range(self, ast):
        return ast

    def newranges(self, ast):
        return ast

    def newrange(self, ast):
        return ast

    def negative_newrange(self, ast):
        return ast

    def subexp(self, ast):
        return ast

    def negative(self, ast):
        return ast

    def non_terminal(self, ast):
        return ast

    def terminal(self, ast):
        return ast

    def any(self, ast):
        return ast

    def rewrite(self, ast):
        return ast

    def rewrite_term(self, ast):
        return ast

    def rule_ref(self, ast):
        return ast

    def token_ref(self, ast):
        return ast

    def token_name(self, ast):
        return ast

    def literal(self, ast):
        return ast

    def id(self, ast):
        return ast

    def name(self, ast):
        return ast

    def lower_name(self, ast):
        return ast

    def upper_name(self, ast):
        return ast

    def char(self, ast):
        return ast

    def string(self, ast):
        return ast

    def STRING(self, ast):
        return ast

    def int(self, ast):
        return ast

    def ESC(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = ANTLRParser()
    return parser.parse(text, startrule, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, ANTLRParser, name='ANTLR')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
